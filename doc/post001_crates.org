* crates and cargo
  This post is aimed at collecting some notes for crates usage,
  ~cargo~ is a fundamental element of this description being the main
  toolchain manager

  This require some knowledge about how cargo works and how rust
  groups code: you can find other references in the 7th chapter of the
  Rust Book
** a few things about cargo
*** basic default file layout for cargo
 cargo has a default layout: with the same toml you may expect
   - a binary project as generated by 
 #+begin_example
 projectname/
 |
 +- Cargo.toml
 |
 +- src/
    |
    +- main.rs
 #+end_example

   - a library project
 #+begin_example
 projectname/
 |
 +- Cargo.toml
 |
 +- src/
    |
    +- lib.rs
 #+end_example

 in both case you get compilation with
 #+begin_src bash
 cargo build
 #+end_src

 while in the binary case you can also run the code with
 #+begin_src
 cargo run
 #+end_src

*** compilation target basics
 ~cargo~ has some commands and options aimed to compile differently the
 code and possibly also choose specific output

 When compiling the code with commands ~build~ or ~run~ the default
 target is ~dev~ while production compilation requires the flag
 ~cargo build --release~

*** library and tests
 library example generated by ~cargo new projectname --lib~ contains
 some test example to start unit testing: looks like this is the
 suggested feature

 #+begin_src rust -n 1
 #[cfg(test)]
 mod tests {
     #[test]
     fn it_works() {
         assert_eq!(2 + 2, 4);
     }
 }
 #+end_src

 - line 1 contains a macro that ensure the following entity to be
   compiled only if the "test" target is selected, which is what happens running
 - line 2 starts a module within this file, this will be compiled only
   according to the macro at line 1
 - line 3 contains a macro which will add some boilerplate code used
   to execute the following function and collect its result when
   executing tests
 - line 5 contains a macro checking the two arguments for equality and
   then raising an exception if the do not equals
   - equality is defined by a specific trait
   - if the exception is raised the test is failed
 #+begin_src bash :eval no-export
 cargo test
 #+end_src

 - this command also executes all the tests
** how rust groups code
*** the code hierarchy
   Rust uses this hierarchical structure
   #+begin_example
   +- packages
      |
      +- crates
         |
         +- modules
            |
            +- functions
            |
            +- structures
            |
            +- traits
   #+end_example
   packages are the highest level: they can be external, built-in
   (e.g. ~std~) or user created. Each project defined by a Cargo.toml
   is a package

   Each package can contain a hierarchy of crates, which means they
   have the same root and do not have circular dependencies

   Each crate can contain a hierarchy of modules with possibly
   different access permissions

   actual code is always in the modules
*** the crate and modules default

    when creating a library project with cargo the ~lib.rs~ file
    contains the code which will be attributed by default to the crate
    with the same name as the project

    all modules are defined by using the ~mod~ keyword followed by a
    block; modules definition can be nested

    Modules act as namespace and as incapsulation protection. While
    modules on the same file are accessible, their inner objects
    should be marked as ~pub~ (short for public) to be accessible
    #+name: nested-module-example
    #+begin_src rust :eval no-export
      mod mymodule {
          pub fn myfunc(){}
          pub mod mysubmodule{
              pub fn myotherfunc(){}
          }
      }
    #+end_src

    accessing modules from within the same file can be done via a path
    #+name: nested-module-basic-usage
    #+begin_src rust :eval no-export
      fn main(){
          mymodule::myfunc();
          mymodule::mysubmodule::myotherfunc();
      }
    #+end_src

    #+begin_src rust :noweb yes :tangle ../examples/basic_nested_modules.rs :exports none :eval no-export
      <<nested-module-example>>
    
      <<nested-module-basic-usage>>
    #+end_src
*** use keyword and navigating the crate hierarchy
    
** mixing all together
*** other compilation targets
 files in the ~examples~ and ~tests~ are compiled according to the appropriate target   
 #+begin_example
 projectname/
 |
 +- Cargo.toml
 |
 +- src/
 |  |
 |  +- lib.rs
 |
 +- examples/
 |
 +- tests/
 #+end_example

 e.g. the following command
 #+begin_src bash :eval no-export
 cargo build --example mycode
 #+end_src

 will compile the file ~examples/mycode.rs~; to run it
 #+begin_src bash :eval no-export
 cargo run --example mycode
 #+end_src

 the test command will build and execute also the tests under the
 tests directory.

 But now things starts to be tricky: how can you import the modules in
 the src directory in order to test them?

 the same applies for examples
*** accessing the default crate from test files
    suppose we have the following function in our library
    #+name: my-func
    #+begin_src rust :eval no-export
      pub fn myfunc(){}
    #+end_src

    the crate name is taken from the Cargo.toml name attribute
    #+begin_src rust :tangle ../tests/test_access_base.rs :eval no-export
      use rust_blog;
      #[test]
      fn test_access_base(){
          rust_blog::myfunc();
      }
    #+end_src

    #+begin_src rust :noweb tangle :tangle ../src/lib.rs :exports none :eval no-export
      <<reexport-poly>>
      <<my-func>>
    #+end_src
*** accessing modules from different files
    the following syntax, added to the lib.rs file is doing two actions:
    - the mod command search for a file (in this case in the current directory)
    - the pub modifier re-exports the command
      #+name: reexport-poly
#+begin_src rust :eval no-export
  pub mod poly;
#+end_src

    - this allows to add a test file like the following: note that
      this looks for a ~src/lib.rs~ which in turn redirects to
      ~src/poly.rs~ file
#+begin_src rust :tangle ../tests/test_poly.rs :eval no-export
  use rust_blog::poly;

  mod test {
      #[test]
      fn it_works() {
          assert_eq!(2 + 2, 4);
      }
  }
#+end_src
