#+BLOG: noise on the net
#+POSTID: 21
#+ORG2BLOG:
#+DATE: [2022-01-24 Mon 21:14]
#+OPTIONS: toc:nil num:nil todo:nil pri:nil tags:nil ^:nil
#+CATEGORY: Language learning
#+TAGS: Rust
#+DESCRIPTION: How cargo lays files in a project impacts on Rust modules import when compiling tests and examples
#+TITLE: Crates and cargo
 file:mcclintock-DcoB_NoNl6U-unsplash-2.jpg
#+BEGIN_EXPORT html
Photo by <a href="https://unsplash.com/@kelli_mcclintock?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Kelli McClintock</a> on <a href="https://unsplash.com/s/photos/box?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a>
#+END_EXPORT
  This post is aimed at collecting some notes for crates usage,
  ~cargo~ is a fundamental element of this description being the main
  toolchain manager. It is more a roundup I needed to reconcile
  ~cargo~ file layout and default behavior with rust 

  You can find other references about modules, crates and packages in
  the 7th [[https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html][chapter]] of the Rust Book.

  The code in this post is available [[https://github.com/noiseOnTheNet/cargo_and_crates][on GitHub]] with MIT license.
** a few things about cargo
*** basic default file layout for cargo
 cargo has a default layout: with the same toml you may expect
   - a binary project as generated by 
   #+begin_example
   projectdir/
   ├─ Cargo.toml
   └─ src/
      └─ main.rs
   #+end_example

   - a library project
   #+begin_example
   projectdir/
   ├─ Cargo.toml
   └─ src/
      └─ lib.rs
   #+end_example

 in both case you get compilation with
 #+begin_src bash
 cargo build
 #+end_src

 while in the binary case you can also run the code with
 #+begin_src
 cargo run
 #+end_src

*** compilation target basics
 ~cargo~ has some commands and options aimed to compile differently the
 code and possibly also choose specific output

 When compiling the code with commands ~build~ or ~run~ the default
 target is ~dev~ while production compilation requires the flag
 ~cargo build --release~ : this triggers also some optimizations.

*** library and tests
 library example generated by ~cargo new projectname --lib~ contains
 some test example to start unit testing: looks like this is the
 suggested feature

 #+begin_src rust -n 1
 #[cfg(test)]
 mod tests {
     #[test]
     fn it_works() {
         assert_eq!(2 + 2, 4);
     }
 }
 #+end_src

 - line 1 contains a macro that ensure the following entity to be
   compiled only if the "test" target is selected, which is what
   happens running ~cargo test~
 - line 2 starts a module within this file, this will be compiled only
   according to the macro at line 1
 - line 3 contains a macro which will add some boilerplate code used
   to execute the following function and collect its result when
   executing tests
 - line 5 contains a macro checking the two arguments for equality and
   then raising an exception if the do not equals
   - equality is defined by a specific trait
   - if the exception is raised the test is failed
 #+begin_src bash :eval no-export
 cargo test
 #+end_src

 - this command also executes all the tests
** how rust groups code
*** the code hierarchy
   Rust uses this hierarchical structure
   #+begin_example
   packages
   └─ crates
      └─ modules
         ├─ functions
         ├─ structures and enums
         └─ traits
   #+end_example
   packages are the highest level: they can be external, built-in
   (e.g. ~std~) or user created. Each project defined by a Cargo.toml
   is a package

   Each package can contain a hierarchy of crates, which means they
   have the same root and do not have circular dependencies

   Each crate can contain a hierarchy of modules with possibly
   different access permissions

   actual code is always in the modules
*** the crate and modules default

    when creating a library project with cargo the ~lib.rs~ file
    contains the code which will be attributed by default to the crate
    with the same name as the project

    all modules are defined by using the ~mod~ keyword followed by a
    block; modules definition can be nested

    Modules act as namespace and as incapsulation protection. While
    modules on the same file are accessible, their inner objects
    should be marked as ~pub~ (short for public) to be accessible
    #+name: nested-module-example
    #+begin_src rust :eval no-export
      mod mymodule {
          pub fn myfunc(){}
          pub mod mysubmodule{
              pub fn myotherfunc(){}
          }
      }
    #+end_src

    accessing modules from within the same file can be done via a path
    #+name: nested-module-basic-usage
    #+begin_src rust :eval no-export
      fn main(){
          mymodule::myfunc();
          mymodule::mysubmodule::myotherfunc();
      }
    #+end_src

    #+begin_src rust :noweb yes :tangle ../examples/basic_nested_modules.rs :exports none :eval no-export
      <<nested-module-example>>
    
      <<nested-module-basic-usage>>
    #+end_src
*** use keyword and navigating the crate hierarchy
The rust book has a nice [[https://doc.rust-lang.org/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html][section]] dedicated to this subject.
The main takeaways are:
1. the ~use~ keyword let you access other modules in the hierarchy:
   levels are separated by a double colon ::
   #+begin_src rust
     use std::io;
   #+end_src
2. a module in the current project can refer to its ancestors using the
   ~super~ keyword at the beginning of the sequence
   #+begin_src rust
     use super::another::branch;
   #+end_src
3. the root of all modules in this project is referred with the keyword crate
   #+begin_src rust
     use crate::sublevel;
   #+end_src
4. one or more elements can be exposed out of their modules; possible
   clashes can be handled using aliases
   #+begin_src rust
     use std::io::Result;
     use std::io::{self, Write};
     use std::fmt::Result as FmtResult;
   #+end_src
** mixing all together
*** other compilation targets
 files in the ~examples~ and ~tests~ are compiled according to the appropriate target   
   #+begin_example
   projectdir/
   ├─ Cargo.toml
   ├─ src/
   │  └─ lib.rs
   ├─ examples/
   └─ tests/
   #+end_example

 e.g. the following command
 #+begin_src bash :eval no-export
 cargo build --example mycode
 #+end_src

 will compile the file ~examples/mycode.rs~; to run it
 #+begin_src bash :eval no-export
 cargo run --example mycode
 #+end_src

 the test command will build and execute also the tests under the
 tests directory.

 But now things starts to be tricky: how can you import the modules in
 the src directory in order to test them?

 the same applies for examples
*** accessing the default crate from test files
    suppose we have the following function in our library
    #+name: my-func
    #+begin_src rust :eval no-export
      pub fn myfunc(){}
    #+end_src

    the crate name is taken from the Cargo.toml name attribute
    #+begin_src rust :tangle ../tests/test_access_base.rs :eval no-export
      use rust_blog;
      #[test]
      fn test_access_base(){
          rust_blog::myfunc();
      }
    #+end_src

    #+begin_src rust :noweb tangle :tangle ../src/lib.rs :exports none :eval no-export
      <<reexport-poly>>
      <<my-func>>
    #+end_src
*** accessing modules from different files
    the following syntax, added to the lib.rs file is doing two actions:
    - the mod command search for a file (in this case in the current directory)
    - the pub modifier re-exports the command
      #+name: reexport-poly
#+begin_src rust :eval no-export
  pub mod poly;
#+end_src

    - this allows to add a test file like the following: note that
      this looks for a ~src/lib.rs~ which in turn redirects to
      ~src/poly.rs~ file
#+begin_src rust :tangle ../tests/test_poly.rs :eval no-export
  use rust_blog::poly;

  mod test {
      #[test]
      fn it_works() {
          assert_eq!(2 + 2, 4);
      }
  }
#+end_src
